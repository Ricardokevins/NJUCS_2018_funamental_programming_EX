#include<iostream>
#include<cstdlib>
using namespace std;
//使用了桶来保存数据，免除了排序，也节约了空间
void mygetnum(char *A, int *B)
{
	for (; *A != '\0'; A++)
	{
		if (*A <= '9'&&*A > '0')
		{
			int j = *A - '0';
			B[j]++;
			A++;
			continue;

		}
		if (*A == 'J'&&*(A + 1) == 'O'&&*(A+2)=='K')
		{
			int j = 15;
			B[j]++;
			A += 4;
			continue;
		}
		if (*A == 'j'&&*(A + 1) == 'o')
		{
			int j = 14;
			B[j]++;
			A += 4;
			continue;
		}
		if (*A == 'J')
		{
			int j = 11;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'Q')
		{
			int j = 12;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'K')
		{
			int j = 13;
			B[j]++;
			A++;
			continue;
		}
	}
}
//对于对手不同的出牌的模式进行思考
int singlecard(int *cardnum, int q)
{
	for (int i(q+1); i < 16; i++)
	{
		if (cardnum[i] > 0)
		{
			cout << i << endl;
			return i;
		}
	}
	return -1;
}
int doublecard(int *cardnum, int q)
{
	for (int i(q+1); i < 16; i++)
	{
		if (cardnum[i] > 1)
		{
			cout << i << " " << i << endl;
			return i;
		}
	}
	return -1;
}
int triblecard(int *cardnum, int q, int p)
{
	for (int i(q+1); i < 16; i++)
	{
		if (cardnum[i] > 2)
		{
			if (p == 0)
			{
				cout << i << " " << i << " " << i << " " << endl;
				return i;
			}
			for (int j(0); j < 16; j++)
			{
				if (cardnum[j] >= p)
				{
					if(p==1)
						cout << i << " " << i << " " << i << " " << j << endl;
					else 
						cout<<i<<" " << i << " " << i << " " << j <<" "<< j << endl;
					return 1;
				}	
#include<iostream>
#include<cstdlib>
using namespace std;
#define max 18
//使用了桶来保存数据，免除了排序，也节约了空间
//3-10是正常的数据，JQK是11-13，A是14，2是15，最后的是大小王
void mygetnum(char *A, int *B)
{
	for (; *A != '\0'; A++)
	{
		if (*A <= '9'&&*A >= '3')
		{
			int j = *A - '0';
			B[j]++;
			A++;
			continue;

		}
		if (*A == '1'&&*(A + 1) == '0')
		{
			int j = 10;
			B[j]++;
			A += 2;
		}
		if (*A == 'J'&&*(A + 1)!='O')
		{
			int j = 11;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'Q')
		{
			int j = 12;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'K')
		{
			int j = 13;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'A')
		{
			int j = 14;
			B[j]++;
			A++;
			continue;
		}
		if (*A =='2')
		{
			int j =15;
			B[j]++;
			A++;
			continue;
		}
		if (*A == 'j'&&*(A + 1) == 'o')
		{
			int j = 16;
			B[j]++;
			A += 4;
			continue;
		}
		if (*A == 'J'&&*(A + 1) == 'O'&&*(A + 2) == 'K')
		{
			int j = 17;
			B[j]++;
			A += 4;
			continue;
		}
	}
}
//写了一个找到桶里的最多牌数并返回大小的函数
int findmax(int *B,int *num)//num就是张数，返回的是牌的值
{
	int pos(3);
	for (int i(3); i < max; i++)
	{
		if (B[i] > B[pos])
		{
			pos = i;
		}
	}
	*num = B[pos];
	return pos;
}
int findit(int *B,int p)//这个函数是为了找到特定的数目的张数，返回值是这个牌的值，如果返回-1就是没有找到
{
	for (int i(3); i < max; i++)
	{
		if (B[i] == p)
		{
			return i;
		}
	}
	return -1;
}
//解析对手的牌
void jiexi(char *A, int *type, int *cardm,int* q,int *p)//type保存的是牌的种类，cardm保存的是牌的数值（最小的），q是带的张数（种类，一张还是一对的），p是连续的张数。
{
	int B[18] = {};
	B[0] = 0;
	B[1] = 0;
	B[2] = 0;
	mygetnum(A,B);
	int allnum(0);
	//计算对方的出牌数
	int initmax1(0);
	int initmax2 = findmax(B, &initmax1);
	if (initmax1 == 1)//顺子的可能性
	{
		if (B[16] == 1 && B[17] == 1)
		{
			*type = 41;
			return;
		}
		int singlenum(0);
		for (int i(3); i < max; i++)
		{
			if (B[i] == 1)
			{
				singlenum++;
			}
		}
		if (singlenum != 1)
		{
			*type = 7;
			*p = singlenum;
			*cardm = initmax2;
			return;
		}

	}
	if (initmax1 == 2)//排除连对的可能性
	{
		int doublenum(0);
		for (int i(3); i < max; i++)
		{
			if (B[i] == 2)
			{
				doublenum++;
			}
		}
		if (doublenum != 1)
		{
			*type = 8;
			*p = doublenum;
			*cardm = initmax2;
			return;
		}
	}
	for (int i(3); i < max; i++)//计算总的牌数
	{
		allnum += B[i];
	}
	if (allnum == 1)
	{
		*type = 1;
		int k(0);
		*cardm = findmax(B, &k);
		return;
	}
	if (allnum == 2)
	{
		*type = 2;
		int k(0);
		*cardm = findmax(B, &k);
		return;
	}
	if (allnum == 3)
	{
		*type = 3;
		int k(0);
		*cardm = findmax(B,&k);
		*q = 0;
		return;
	}
	if (allnum == 4)
	{
		int maxnumzhang = 0;
		int maxnumzhi=findmax(B,&maxnumzhang);
		if (maxnumzhang == 4)
		{
			*type = 4;
			*cardm = maxnumzhi;
			return;
		}
		if (maxnumzhang == 3)
		{
			*type = 3;
			*cardm = maxnumzhi;
			*q = 1;
			return;
		}
	}
	if (allnum == 5)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//三带二
		{
			*type = 3;
			*cardm = maxnumzhi;
			*q = 2;
			return;
		}
	}
	if (allnum == 6)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//飞机不带
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 0;
			*p = 2;
			return;
		}
		if (maxnumzhang == 4)//四带二
		{
			*type = 5;
			*cardm = maxnumzhi;
			*q = 1;
			return;
		}
	}
	if (allnum == 8)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//飞机带一
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 1;
			*p = 2;
			return;
		}
		if (maxnumzhang == 4)//四带二对
		{
			*type = 5;
			*cardm = maxnumzhi;
			*q = 2;
			return;
		}
	}
	if (allnum == 9)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//三飞机不带
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 0;
			*p = 3;
			return;
		}
	}
	if (allnum == 10)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//二飞机带两对
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 2;
			*p = 2;
			return;
		}
	}
	if (allnum == 12)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//三飞机带一
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 1;
			*p = 3;
			return;
		}
	}
	if (allnum == 15)
	{
		int maxnumzhang = 0;
		int maxnumzhi = findmax(B, &maxnumzhang);
		if (maxnumzhang == 3)//三飞机带二
		{
			*type = 6;
			*cardm = maxnumzhi;
			*q = 2;
			*p = 3;
			return;
		}
	}

}
//对于对手不同的出牌的模式进行思考
//编号为第一种，单张
int singlecard(int *cardnum, int q)
{
	for (int i(q+1); i < max; i++)
	{
		if (cardnum[i] > 0)
		{
			cout << i << endl;
			cardnum[i]--;
			return i;
		}
	}
	return -1;
}
//编号为第二种，对子
int doublecard(int *cardnum, int q)
{
	for (int i(q+1); i < max; i++)
	{
		if (cardnum[i] > 1)
		{
			cout << i << " " << i << endl;
			cardnum[i] -= 2;
			return i;
		}
	}
	return -1;
}
//编号为第三种，三张
int triblecard(int *cardnum, int q, int p)
{
	for (int i(q+1); i < max; i++)
	{
		if (cardnum[i] > 2)
		{
			if (p == 0)
			{
				cout << i << " " << i << " " << i << " " << endl;
				cardnum[i] -= 3;//张数减少避免可能的牌重复出
				return i;
			}
			for (int j(3); j < max; j++)
			{
				if (cardnum[j] >= p)
				{
					if (p == 1)
					{
						cout << i << " " << i << " " << i << " " << j << endl;
						cardnum[j]--;
					}

					else
					{
						cout << i << " " << i << " " << i << " " << j << " " << j << endl;
						cardnum[j] -= 2;
					}
					return 1;
				}
			}
			cardnum[i] += 3;//组合失败就重新回去计算
		}

	}
	return -1;
}
//第四，炸弹
int bombcard(int *cardnum, int q)
{
	for (int i(q+1); i < max; i++)
	{
		if (cardnum[i] == 4)
		{
			for (int j(0); j < 4; j++)
			{
				cout << i << " ";
			}
			cout << endl;
			cardnum[i] -= 4;
			return i;
		}
	}
	if (cardnum[16] == 1 && cardnum[17] == 1)
	{
		cardnum[16]--; 
		cardnum[17]--;
		cout << "Rocket!!!" << endl;
		return 0;
	}
	return -1;
}
//第五，四带二
int forthcard(int *cardnum, int q, int p)
{
	for (int i(q + 1); i < max; i++)
	{
		if (cardnum[i] == 4)
		{
			cardnum[i] -= 4;
			int d1(0);
			int d2(0);
			int paishu(0);
			for (int j(3); j < max; j++)
			{
				if (cardnum[j] >= p)
				{
					paishu++;
					if (paishu == 1)
					{
						d1 = j;
					}
					if (paishu == 2)
					{
						d2 = j;
						if (p == 1)
						{
							cout << i << " " << i << " " << i << " " << i << " " << d1 << " " << d2 << endl;
							cardnum[d1] -= 1;
							cardnum[d2] -= 1;
							return 1;
						}
						else
						{
							cout << i << " " << i << " " << i << " " << i << " " << d1 << " " << d1 << " " << d2 << " " << d2 << endl;
							cardnum[d1] -= 2;
							cardnum[d2] -= 2;
							return 1;
						}
					}
				}
			}
			cardnum[i] += 4;
			return -1;
		}
	}
	return -1;
}
//第六，飞机
int planecard(int *cardnum, int q,int p,int s)//仍然是q代表的是三的最小的起点，然后后面表示的是带的张数，最后是飞机的连续数目
{
	if (s == 2)
	{
		for (int i(q); i < max - 1; i++)
		{
			int k(0);
			for (; k < 2; k++)//从当前的起点开始向后面找s个数值的牌是否也是飞机
			{
				if (cardnum[i + k] < 3)
					break;
			}
			if (k == 2)
			{
				cardnum[i] -= 3;
				cardnum[i + 1] -= 3;
				int daipaishu(0);
				int d1(0);
				int d2(0);
				for (int d(3); d < max; )
				{
					if (cardnum[d] >= p)
					{
						daipaishu++;
						if (p == 1)
						{
							cardnum[d]--;
						}
						else
							cardnum[d]-=2;
						if (daipaishu == 2)
						{
							d2 = d;
							break;
						}
						else
							d1 = d;
						
					}
					else
						d++;
				}
				if (daipaishu == 2 && p == 1)
				{
					cout << i << " " << i << " " << i << " " << i + 1 << " " << i + 1 << " " << i + 1 << " " << d1 << " " << d2 << endl;
					return 1;
				}
				else
				{
					if (daipaishu == 2 && p == 2)
					{						
						cout << i << " " << i << " " << i << " " << i + 1 << " " << i + 1 << " " << i + 1 << " " << d1 << " " << d1 << " " << d2 << " " << d2 << endl;
						return 1;
					}
					else
						return -1;
				}

			}
		}
		return -1;
	}
	if (s == 3)
	{
		for (int i(q); i < max - 1; i++)
		{
			int k(0);
			for (; k < 3; k++)//从当前的起点开始向后面找s个数值的牌是否也是飞机
			{
				if (cardnum[i + k] < 3)
					break;
			}
			if (k == 3)
			{
				cardnum[i] -= 3;
				cardnum[i + 1] -= 3;
				cardnum[i + 2] -= 3;
				int daipaishu(0);
				int d1(0);
				int d2(0);
				int d3(0);
				for (int d(3); d < max; d++)
				{
					if (cardnum[d] >= p)
					{
						daipaishu++;
						if (daipaishu == 1)
						{
							d1 = d;
						}
						if (daipaishu == 2)
						{
							d2 = d;
						}
						if (daipaishu == 3)
						{
							d3 = d;
							break;
						}
						
					}
				}
				if (daipaishu == 3 && p == 1)
				{
					cout << i << " " << i << " " << i << " " << i + 1 << " " << i + 1 << " " << i + 1 << " " << d1 << " " << d2 << " " << d3 << endl;
				}
				else
				{
					if (daipaishu == 3 && p == 2)
					{
						cout << i << " " << i << " " << i << " " << i + 1 << " " << i + 1 << " " << i + 1 << " " << d1 << " " << d1 << " " << d2 << " " << d2 << " " << d3 << " " << d3 << endl;
					}
					else
						return -1;
				}

			}
		}
		return -1;
	}
	return -1;
}

//第七，顺子
int shunzi(int *cardnum, int q, int p)//仍然q作为开始点的数值，p是连续的数量
{
	for (int i(q); i < max - p + 1; i++)
	{
		int j = i;
		for (; j < 16; j++)//顺子最大到2为止，对应的数值就是15+1
		{
			if (cardnum[j] < 1)
				break;
		}
		if (j - i + 1 >= p)
		{
			for (int ws(0); ws < p; ws++)
			{
				cout << i + ws << " ";
			}
			cout << endl;
			return 1;
		}
	}
	return -1;
}
//第八，连对
int doubleshunzi(int *cardnum, int q, int p)
{

	for (int i(q); i < max - p + 1; i++)
	{
		int j = i;
		for (; j < 16; j++)//顺子最大到2为止，对应的数值就是15+1
		{
			if (cardnum[j] < 2)
				break;
		}
		if (j - i  >= p)
		{
			for (int ws(0); ws < p; ws++)
			{
				cout << i + ws << " ";
				cout << i + ws << " ";
			}
			cout << endl;
			return 1;
		}
	}
	return -1;
}
int main()
{
	//A是输入的我的牌
	char A[100] = {};
	A[0] = getchar();
	int i(0);
	for (; A[i] != '\n';)
	{
		i++;
		A[i] = getchar();
		
	}
	A[i] = '\0';
	//B是对我的手牌进行转化为数字
	int B[18] = {};
	B[0] = 0;
	B[1] = 0;
	B[2] = 0;
	mygetnum(A, B);
	int j(1);
	//调试0
	
	for (int s(3); s < 18; s++)
	{
		cout << s << "\t";
	}
	cout << endl;
	for (int j(3); j<18; j++)
	{
		cout << B[j] <<"\t";
	}
	cout << endl;
	/*
	if (singlecard(B, 3) == -1)  cout << -1 << endl;
	if (doublecard(B, 3) == 1) cout << -1 << endl;
	if (triblecard(B, 3, 2) == -1) cout << -1 << endl;
	if (bombcard(B, 5)== -1) cout << -1 << endl;
	if (forthcard(B, 3, 2) == -1) cout << -1 << endl;
	for (int j(3); j < 18; j++)
	{
		cout << B[j] << "\t";
	}
	cout << endl;
	return 0;
	
	
	int mynum(0);
	cout << findmax(B,&mynum)<<endl;
	cout << mynum;
	
	//测试解析函数
	int type = 0;
	int cardm = 0;
	int q = 0;
	int p = 0;
	jiexi(A, &type, &cardm, &q, &p);
	cout << type << endl;//手牌种类
	cout << cardm << endl;//手牌起始值
	cout << q << endl;//带的张数种类
	cout << p << endl;//连续的数目
	*/
	//if (singlecard(B, 3) == -1)  cout << -1 << endl;
	//if (doublecard(B, 3) == 1) cout << -1 << endl;
	//if (triblecard(B, 3, 2) == -1) cout << -1 << endl;
	//if (bombcard(B, 5) == -1) cout << -1 << endl;
	//if (forthcard(B, 3, 2) == -1) cout << -1 << endl;
	if (planecard(B, 3, 1,2) == -1) cout << -1 << endl;
	//if (shunzi(B, 3, 5) == -1) cout << -1 << endl;
	//if (doubleshunzi(B, 3, 3) == -1) cout << -1 << endl;

}
